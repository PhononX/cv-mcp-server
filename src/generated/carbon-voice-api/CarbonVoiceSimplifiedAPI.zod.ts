/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * Carbon Voice Simplified API
 * # Introduction

The simplified version of the Carbon Voice API is designed to enhance usability for third-party clients looking to 
seamlessly integrate with our application. By streamlining authentication methods, providing clear error handling guidelines, 
and implementing straightforward rate limiting policies, we ensure that developers can quickly and efficiently connect to our services. 
This user-friendly approach minimizes complexity, making it easier for external applications to leverage the powerful communication 
features of Carbon Voice without extensive technical overhead.

This API is designed for people who feel comfortable integrating with RESTful APIs.

## Full API Version
We also have a full version of the API. You can find it [here](/docs).

## Terminology
 
* **Workspace**: An area that groups together people and Conversations.
* **Conversation**: A channel of communication. A grouping of people and messages related to a given topic.
* **Collaborators**: A group of people who are part of a Conversation.
* **Discussion**: Any post into a conversation
* **CarbonLink**: A link (on a website, QR code, or phone call) to start a conversation.

## BaseURL

This API is served over HTTPS.

All URLs referenced in the documentation have the following base: https://api.carbonvoice.app/api/simplified.

## Authentication

There are three ways to authenticate with this API:

* with an OAuth2 Access Token in the Authorization request header field 
(which uses the Bearer authentication scheme to transmit the Access Token)
* with your Client ID and Client Secret credentials
* with a PXToken

Each endpoint supports only one option.

<SecurityDefinitions />

## Errors

When an error occurs, you will receive an error object. Most of these error objects 
contain an error code and an error description so that your applications can more 
efficiently identify the problem.

If you get an 4xx HTTP response code, then you can assume that there is a bad request
from your end. In this case, check the [Error Responses section](#section/Introduction/Error-Responses) for more context.

5xx errors suggest a problem on our end, so in this case, check [Carbon Voice's Status](https://status.carbonvoice.app)
 to see how our systems are doing.

In any other case you can use our support options.

## Error Responses

`{ "success": false, requestId: "uuid", errmsg: "error message"`

## Rate-Limiting 

This API is subject to rate limiting. The limits differ per endpoint.

If you exceed the provided rate limit for a given endpoint, you will receive the 429
Too Many Requests response with the following message: Too many requests. Check the
X-RateLimit-Limit, X-RateLimit-Remaining and X-RateLimit-Reset headers.

For details on rate limiting, refer to Rate Limit Policy.

## Support

If you have problems or need help with your case, you can always reach out to our Support.

 * OpenAPI spec version: 1.0.0
 */
import {
  z as zod
} from 'zod';


export const aIPromptControllerGetPromptsQueryParams = zod.object({
  "owner_type": zod.enum(['user', 'workspace', 'system']).optional(),
  "workspace_id": zod.string().optional()
})

export const aIPromptControllerGetPromptsResponseNameMax = 100;
export const aIPromptControllerGetPromptsResponseDescriptionMax = 500;


export const aIPromptControllerGetPromptsResponseItem = zod.object({
  "id": zod.string(),
  "created_at": zod.string().datetime({}),
  "last_updated_at": zod.string().datetime({}),
  "creator_id": zod.string(),
  "workspace_id": zod.string().optional(),
  "prompt": zod.string(),
  "name": zod.string().max(aIPromptControllerGetPromptsResponseNameMax),
  "description": zod.string().max(aIPromptControllerGetPromptsResponseDescriptionMax).optional(),
  "format_instructions": zod.string().optional(),
  "response_format": zod.enum(['text', 'json']).optional(),
  "owner_type": zod.enum(['user', 'workspace', 'system']),
  "category_number": zod.number().optional(),
  "order_in_category": zod.number().optional()
})
export const aIPromptControllerGetPromptsResponse = zod.array(aIPromptControllerGetPromptsResponseItem)


export const aIPromptControllerCreatePromptBody = zod.object({
  "workspace_id": zod.string().optional(),
  "prompt": zod.string(),
  "name": zod.string(),
  "description": zod.string().optional(),
  "format_instructions": zod.string().optional(),
  "response_format": zod.enum(['text', 'json']),
  "owner_type": zod.enum(['user', 'workspace', 'system'])
})


export const aIPromptControllerDeletePromptParams = zod.object({
  "id": zod.string()
})


export const aIResponseControllerGetAllResponsesQueryLimitDefault = 50;

export const aIResponseControllerGetAllResponsesQueryParams = zod.object({
  "message_id": zod.string().optional(),
  "prompt_id": zod.string().optional(),
  "channel_id": zod.string().optional(),
  "limit": zod.number().default(aIResponseControllerGetAllResponsesQueryLimitDefault),
  "direction": zod.enum(['older', 'newer']).optional(),
  "date": zod.string().datetime({}).optional()
})

export const aIResponseControllerGetAllResponsesResponseItem = zod.object({
  "id": zod.string(),
  "creator_id": zod.string(),
  "prompt_id": zod.string(),
  "created_at": zod.string().datetime({}),
  "last_updated_at": zod.string().datetime({}),
  "responses": zod.array(zod.object({
  "language": zod.string().describe('Language'),
  "json": zod.record(zod.string(), zod.string().or(zod.number()).or(zod.boolean()).or(zod.object({

})).or(zod.array(zod.string()))).optional().describe('Json format'),
  "text": zod.string().optional().describe('Text format'),
  "html": zod.string().optional().describe('Html format'),
  "markdown": zod.string().optional().describe('Markdown format')
})).describe('Responses by language'),
  "message_ids": zod.array(zod.string()),
  "workspace_id": zod.string().optional(),
  "channel_id": zod.string().optional()
})
export const aIResponseControllerGetAllResponsesResponse = zod.array(aIResponseControllerGetAllResponsesResponseItem)


export const aIResponseControllerCreateResponseBody = zod.object({
  "prompt_id": zod.string(),
  "message_ids": zod.array(zod.string()),
  "channel_id": zod.string().optional(),
  "workspace_id": zod.string().optional(),
  "language": zod.string().optional().describe('The language of the response. Defaults to original message.')
})


export const aIResponseControllerGetLatestTenAIResponseByPromptParams = zod.object({
  "prompt_id": zod.string()
})

export const aIResponseControllerGetLatestTenAIResponseByPromptResponseResultsItemMessagesItemMessageLanguageDefault = "english";

export const aIResponseControllerGetLatestTenAIResponseByPromptResponse = zod.object({
  "results": zod.array(zod.object({
  "ai_response": zod.object({
  "id": zod.string(),
  "prompt_id": zod.string(),
  "creator_id": zod.string(),
  "responses": zod.array(zod.object({
  "language": zod.string().describe('Language'),
  "json": zod.record(zod.string(), zod.string().or(zod.number()).or(zod.boolean()).or(zod.object({

})).or(zod.array(zod.string()))).optional().describe('Json format'),
  "text": zod.string().optional().describe('Text format'),
  "html": zod.string().optional().describe('Html format'),
  "markdown": zod.string().optional().describe('Markdown format')
})),
  "message_ids": zod.array(zod.string()),
  "workspace_id": zod.string().optional(),
  "channel_id": zod.string().optional(),
  "user_id": zod.string(),
  "last_updated_at": zod.string().datetime({}),
  "created_at": zod.string().datetime({})
}),
  "messages": zod.array(zod.object({
  "message": zod.object({
  "id": zod.string().describe('ID'),
  "name": zod.string().optional().describe('Name'),
  "link": zod.string().describe('Link to Message'),
  "creator_id": zod.string().describe('Creator ID'),
  "conversation_id": zod.string().optional().describe('Conversation ID'),
  "workspace_id": zod.string().optional().describe('Workspace ID'),
  "created_at": zod.string().datetime({}),
  "last_updated_at": zod.string().datetime({}),
  "deleted_at": zod.string().datetime({}).optional(),
  "duration_ms": zod.number().describe('The length of the message in milliseconds'),
  "audio_url": zod.string().optional().describe('The URL for the message audio file'),
  "audio_stream_url": zod.string().optional().describe('The URL for the message audio stream'),
  "transcript": zod.string().optional().describe('Transcript of the message'),
  "ai_summary": zod.string().optional().describe('AI Summary generated of the message'),
  "waveform_url": zod.string().optional().describe('The URL for the message waveform image'),
  "reply_count": zod.number().describe('The number of replies to the message'),
  "parent_message_id": zod.string().optional().describe('Parent Message unique ID (only available for replies)'),
  "language": zod.string().default(aIResponseControllerGetLatestTenAIResponseByPromptResponseResultsItemMessagesItemMessageLanguageDefault).describe('Language for the message (Transcript, AI summary, Audio...)'),
  "status": zod.enum(['offline', 'paused', 'processing', 'scheduled', 'active', 'deleted', 'account-deleted', 'initializing', 'inprogress', 'canceled', 'failed']).describe('Current status of the Message'),
  "type": zod.enum(['channel', 'prerecorded', 'voicememo', 'stored', 'welcome']).describe('Type of the Message'),
  "attachments": zod.array(zod.object({
  "id": zod.string(),
  "creator_id": zod.string(),
  "created_at": zod.string().datetime({}),
  "type": zod.enum(['link', 'file', 'location']),
  "link": zod.string(),
  "active_begin": zod.string().datetime({}).optional(),
  "active_end": zod.string().datetime({}).optional(),
  "filename": zod.string().optional(),
  "mime_type": zod.string().optional(),
  "length_in_bytes": zod.number().optional(),
  "location": zod.object({

}).optional()
})).optional().describe('List of attachments for the message'),
  "share_link_id": zod.string().optional().describe('Share Link ID to a message'),
  "folder_id": zod.string().optional().describe('Folder ID where the message is stored')
}),
  "creator": zod.object({
  "id": zod.string().describe(' ID'),
  "link": zod.string().describe('Link to User'),
  "created_at": zod.string().datetime({}),
  "first_name": zod.string().describe('First Name'),
  "last_name": zod.string().optional().describe('Last Name'),
  "full_name": zod.string().describe('Full Name'),
  "image_url": zod.string().optional().describe('Image Url'),
  "emails": zod.array(zod.string()).optional().describe('List of emails (First one is the primary)'),
  "phones": zod.array(zod.string()).optional().describe('List of phones (First one is the primary)'),
  "languages": zod.array(zod.string()).optional().describe('List of languages (First one is the primary)')
}).optional(),
  "conversation": zod.object({
  "id": zod.string().describe('ID'),
  "link": zod.string().describe('Link to Conversation'),
  "name": zod.string().describe('Name'),
  "description": zod.string().optional().describe('Description'),
  "workspace_id": zod.string().describe('Workspace ID'),
  "workspace_name": zod.string().describe('Workspace Name'),
  "workspace_image_url": zod.string().optional().describe('Workspace Image Url'),
  "owner_id": zod.string().describe('owner unique ID'),
  "type": zod.enum(['directMessage', 'customerConversation', 'namedConversation', 'asyncMeeting']).describe('Type'),
  "visibility": zod.enum(['private', 'workspace', 'public']).describe('Visibility'),
  "total_messages": zod.number().describe('Total Messages'),
  "total_duration_ms": zod.number().describe('Total duration in milliseconds'),
  "image_url": zod.string().optional().describe('Image Url'),
  "is_private": zod.boolean().describe('Is Private Conversation'),
  "is_async": zod.boolean().describe('Is Async Conversation'),
  "async_stats": zod.object({
  "stats": zod.object({
  "total_duration_milliseconds": zod.number().describe('Total duration in milliseconds'),
  "total_heard_milliseconds": zod.number().describe('Total heard in milliseconds'),
  "total_engaged_percentage": zod.number().describe('Total engaged percentage'),
  "total_messages_posted": zod.number().describe('Total messages posted'),
  "total_users": zod.number().describe('Total users')
}).describe('Conversation stats'),
  "user_stats": zod.array(zod.object({
  "user_id": zod.string().describe('User unique ID'),
  "total_messages_posted": zod.number().describe('Total messages posted'),
  "total_sent_milliseconds": zod.number().describe('Total sent in milliseconds'),
  "total_heard_milliseconds": zod.number().describe('Total heard in milliseconds'),
  "total_engaged_percentage": zod.number().describe('Total engaged percentage'),
  "total_heard_messages": zod.number().describe('Total heard messages'),
  "total_unheard_messages": zod.number().describe('Total unheard messages')
})).describe('User stats')
}).optional().describe('Async Meeting Stats'),
  "created_at": zod.string().datetime({}),
  "last_updated_at": zod.string().datetime({}),
  "deleted_at": zod.string().datetime({}).optional()
}).optional(),
  "labels": zod.array(zod.object({
  "id": zod.string().describe('ID'),
  "name": zod.string().describe('Name'),
  "behavior": zod.enum(['removeOnListenStart', 'removeWhenHeard', 'persistent']).describe('Behavior'),
  "type": zod.enum(['personal', 'workspace', 'system', 'reaction']).describe('Type'),
  "creator_guid": zod.string().describe('Creator ID'),
  "space_guid": zod.string().optional().describe('Workspace ID'),
  "image_url": zod.string().optional().describe('Image URL'),
  "automatic_playlist": zod.boolean().optional().describe('Automatic Playlist'),
  "sort_order": zod.number().optional().describe('Sort Order')
})).optional()
}))
})).optional()
})


/**
 * @summary Generate AI Prompt Response by share-link-ids
 */
export const createShareLinkAIResponseBody = zod.object({
  "prompt_id": zod.string(),
  "share_link_ids": zod.array(zod.string()),
  "language": zod.string().optional()
})


export const aIResponseControllerDeletePromptParams = zod.object({
  "id": zod.string()
})


/**
 * Apps that the user has access to (subscribed or not). If the user is the owner of the app, details will be returned with the private fields.
 * @summary Get List of My Apps
 */
export const getMyAppsResponseItem = zod.object({
  "id": zod.string().describe('The primary key of the resource.'),
  "name": zod.string(),
  "description": zod.string().optional(),
  "client_id": zod.string(),
  "client_secret": zod.string().optional(),
  "access_token_lifetime_seconds": zod.number().optional().describe('Access token lifetime in seconds'),
  "refresh_token_lifetime_seconds": zod.number().optional().describe('Refresh token lifetime in seconds'),
  "allowed_callback_urls": zod.string().optional().describe('Allowed callback URLs (comma separated list)'),
  "webhooks_url": zod.string().optional().describe('Webhook URL to send the data (comma separated list)'),
  "webhooks_authentication_header": zod.record(zod.string(), zod.string()).optional().describe('Authentication header configuration for webhooks. Key-value pairs where both key and value are strings.'),
  "allowed_logout_urls": zod.string().optional().describe('Allowed logout URLs (comma separated list)'),
  "created_at": zod.string().datetime({}).describe('Created at'),
  "updated_at": zod.string().datetime({}).describe('Updated at'),
  "deleted_at": zod.string().datetime({}).optional().describe('Deleted at'),
  "webhooks_url_mode": zod.enum(['one_per_client', 'one_per_subscription']).describe('Webhook URL mode'),
  "send_invalid_refresh_token_webhook_notification": zod.boolean().optional().describe('Send invalid refresh token webhook notification'),
  "send_webhook_when_invalid_access_or_refresh_token": zod.boolean().optional().describe('Send webhook when invalid access or refresh token'),
  "owner_id": zod.string().optional(),
  "user_is_subscribed_with_valid_tokens": zod.boolean().describe('Indicates whether the user is subscribed to the app and has valid authentication tokens (access or refresh).'),
  "image_url": zod.string().optional().describe('Image URL')
})
export const getMyAppsResponse = zod.array(getMyAppsResponseItem)


/**
 * @summary Subscribe user into app
 */
export const subscribeUserIntoAppParams = zod.object({
  "client_id": zod.string()
})

export const subscribeUserIntoAppBodySubscriptionFiltersItemOperatorDefault = "eq";

export const subscribeUserIntoAppBody = zod.object({
  "subscriptions": zod.array(zod.enum(['message.initializing', 'message.started', 'message.paused', 'message.resumed', 'message.offline', 'message.processing', 'message.finished', 'message.deleted', 'message.discussion-notes.added', 'message.label.added', 'message.posted.to.channel', 'message.voicememo.created', 'channel.created', 'channel.deleted', 'channel.user.joined', 'channel.users.added', 'channel.user.left', 'channel.user.removed', 'channel.async-check.mid', 'channel.async-check.ending', 'channel.async.ended', 'channel.async.extended', 'channel.async.shortened', 'channel.ai-summary.generated', 'workspace.user.joined', 'workspace.user.added', 'workspace.user.left', 'workspace.user.removed', 'workspace.findable-channel.created', 'access_token.expired', 'refresh_token.expired', 'ai.prompt.response.generated'])).optional().describe('All events are subscribed by default: message.initializing, message.started, message.paused, message.resumed, message.offline, message.processing, message.finished, message.deleted, message.discussion-notes.added, message.label.added, message.posted.to.channel, message.voicememo.created, channel.created, channel.deleted, channel.user.joined, channel.users.added, channel.user.left, channel.user.removed, channel.async-check.mid, channel.async-check.ending, channel.async.ended, channel.async.extended, channel.async.shortened, channel.ai-summary.generated, workspace.user.joined, workspace.user.added, workspace.user.left, workspace.user.removed, workspace.findable-channel.created, access_token.expired, refresh_token.expired, ai.prompt.response.generated'),
  "webhookURL": zod.string().optional().describe('Webhook URL to send the data'),
  "subscription_filters": zod.array(zod.object({
  "key": zod.string().describe('What is the key to filter the data before sending to the webhook'),
  "value": zod.string().or(zod.number()).or(zod.array(zod.string())).describe('What is the value to filter the data (string or number)'),
  "operator": zod.enum(['eq', 'ne', 'in']).describe('What is the operator to filter the data')
})).optional(),
  "subscription_actions": zod.array(zod.object({
  "action_id": zod.enum(['run_ai_prompt']).describe('What is the action to perform'),
  "entity_type": zod.enum(['ai_prompt']).optional().describe('What is the entity_type to perform the action on (required when entity_id is provided)'),
  "entity_id": zod.string().optional().describe('What is the entity_id to perform the action on (required when entity_type is provided)')
})).optional().describe('Actions are used only for internal apps. (Not allowed to external apps)')
})

export const subscribeUserIntoAppResponseSubscriptionFiltersItemOperatorDefault = "eq";

export const subscribeUserIntoAppResponse = zod.object({
  "_id": zod.string().describe('The primary key of the resource.'),
  "created_at": zod.string().datetime({}).describe('The date and time at which the resource was created.'),
  "updated_at": zod.string().datetime({}).describe('The date and time at which the resource was last updated.'),
  "id": zod.string().describe('The primary key of the resource.'),
  "client_id": zod.string(),
  "user_id": zod.string(),
  "subscriptions": zod.array(zod.enum(['message.initializing', 'message.started', 'message.paused', 'message.resumed', 'message.offline', 'message.processing', 'message.finished', 'message.deleted', 'message.discussion-notes.added', 'message.label.added', 'message.posted.to.channel', 'message.voicememo.created', 'channel.created', 'channel.deleted', 'channel.user.joined', 'channel.users.added', 'channel.user.left', 'channel.user.removed', 'channel.async-check.mid', 'channel.async-check.ending', 'channel.async.ended', 'channel.async.extended', 'channel.async.shortened', 'channel.ai-summary.generated', 'workspace.user.joined', 'workspace.user.added', 'workspace.user.left', 'workspace.user.removed', 'workspace.findable-channel.created', 'access_token.expired', 'refresh_token.expired', 'ai.prompt.response.generated'])),
  "webhookURL": zod.string().optional().describe('Webhook URL to send the data'),
  "subscription_filters": zod.array(zod.object({
  "key": zod.string().describe('What is the key to filter the data before sending to the webhook'),
  "value": zod.string().or(zod.number()).or(zod.array(zod.string())).describe('What is the value to filter the data (string or number)'),
  "operator": zod.enum(['eq', 'ne', 'in']).describe('What is the operator to filter the data')
})).optional(),
  "subscription_actions": zod.array(zod.object({
  "action_id": zod.enum(['run_ai_prompt']).describe('What is the action to perform'),
  "entity_type": zod.enum(['ai_prompt']).optional().describe('What is the entity_type to perform the action on (required when entity_id is provided)'),
  "entity_id": zod.string().optional().describe('What is the entity_id to perform the action on (required when entity_type is provided)')
})).optional()
})


/**
 * @summary Unsubscribe user from app
 */
export const unsubscribeUserFromAppParams = zod.object({
  "client_id": zod.string()
})


export const languageControllerGetAllResponseItem = zod.object({
  "id": zod.string(),
  "name": zod.string(),
  "code": zod.string(),
  "supported": zod.boolean(),
  "voices": zod.array(zod.object({
  "id": zod.string(),
  "name": zod.string(),
  "type": zod.enum(['polly', 'elevenlabs', 'google', 'openai']),
  "gender": zod.enum(['F', 'M']),
  "quality": zod.enum(['high', 'medium', 'low']),
  "language_code": zod.string()
}))
})
export const languageControllerGetAllResponse = zod.array(languageControllerGetAllResponseItem)


/**
 * @summary Get last ten recent Messages including (Conversation, Creator, Labels)
 */
export const getTenRecentMessagesResponseQueryParams = zod.object({
  "conversation_id": zod.string().optional().describe('Conversation ID (optional)'),
  "language": zod.string().optional().describe('Language (optional) - Original language will be used if not provided or not found.')
})

export const getTenRecentMessagesResponseResponseResultsItemMessageLanguageDefault = "english";

export const getTenRecentMessagesResponseResponse = zod.object({
  "results": zod.array(zod.object({
  "message": zod.object({
  "id": zod.string().describe('ID'),
  "name": zod.string().optional().describe('Name'),
  "link": zod.string().describe('Link to Message'),
  "creator_id": zod.string().describe('Creator ID'),
  "conversation_id": zod.string().optional().describe('Conversation ID'),
  "workspace_id": zod.string().optional().describe('Workspace ID'),
  "created_at": zod.string().datetime({}),
  "last_updated_at": zod.string().datetime({}),
  "deleted_at": zod.string().datetime({}).optional(),
  "duration_ms": zod.number().describe('The length of the message in milliseconds'),
  "audio_url": zod.string().optional().describe('The URL for the message audio file'),
  "audio_stream_url": zod.string().optional().describe('The URL for the message audio stream'),
  "transcript": zod.string().optional().describe('Transcript of the message'),
  "ai_summary": zod.string().optional().describe('AI Summary generated of the message'),
  "waveform_url": zod.string().optional().describe('The URL for the message waveform image'),
  "reply_count": zod.number().describe('The number of replies to the message'),
  "parent_message_id": zod.string().optional().describe('Parent Message unique ID (only available for replies)'),
  "language": zod.string().default(getTenRecentMessagesResponseResponseResultsItemMessageLanguageDefault).describe('Language for the message (Transcript, AI summary, Audio...)'),
  "status": zod.enum(['offline', 'paused', 'processing', 'scheduled', 'active', 'deleted', 'account-deleted', 'initializing', 'inprogress', 'canceled', 'failed']).describe('Current status of the Message'),
  "type": zod.enum(['channel', 'prerecorded', 'voicememo', 'stored', 'welcome']).describe('Type of the Message'),
  "attachments": zod.array(zod.object({
  "id": zod.string(),
  "creator_id": zod.string(),
  "created_at": zod.string().datetime({}),
  "type": zod.enum(['link', 'file', 'location']),
  "link": zod.string(),
  "active_begin": zod.string().datetime({}).optional(),
  "active_end": zod.string().datetime({}).optional(),
  "filename": zod.string().optional(),
  "mime_type": zod.string().optional(),
  "length_in_bytes": zod.number().optional(),
  "location": zod.object({

}).optional()
})).optional().describe('List of attachments for the message'),
  "share_link_id": zod.string().optional().describe('Share Link ID to a message'),
  "folder_id": zod.string().optional().describe('Folder ID where the message is stored')
}),
  "creator": zod.object({
  "id": zod.string().describe(' ID'),
  "link": zod.string().describe('Link to User'),
  "created_at": zod.string().datetime({}),
  "first_name": zod.string().describe('First Name'),
  "last_name": zod.string().optional().describe('Last Name'),
  "full_name": zod.string().describe('Full Name'),
  "image_url": zod.string().optional().describe('Image Url'),
  "emails": zod.array(zod.string()).optional().describe('List of emails (First one is the primary)'),
  "phones": zod.array(zod.string()).optional().describe('List of phones (First one is the primary)'),
  "languages": zod.array(zod.string()).optional().describe('List of languages (First one is the primary)')
}).optional(),
  "conversation": zod.object({
  "id": zod.string().describe('ID'),
  "link": zod.string().describe('Link to Conversation'),
  "name": zod.string().describe('Name'),
  "description": zod.string().optional().describe('Description'),
  "workspace_id": zod.string().describe('Workspace ID'),
  "workspace_name": zod.string().describe('Workspace Name'),
  "workspace_image_url": zod.string().optional().describe('Workspace Image Url'),
  "owner_id": zod.string().describe('owner unique ID'),
  "type": zod.enum(['directMessage', 'customerConversation', 'namedConversation', 'asyncMeeting']).describe('Type'),
  "visibility": zod.enum(['private', 'workspace', 'public']).describe('Visibility'),
  "total_messages": zod.number().describe('Total Messages'),
  "total_duration_ms": zod.number().describe('Total duration in milliseconds'),
  "image_url": zod.string().optional().describe('Image Url'),
  "is_private": zod.boolean().describe('Is Private Conversation'),
  "is_async": zod.boolean().describe('Is Async Conversation'),
  "async_stats": zod.object({
  "stats": zod.object({
  "total_duration_milliseconds": zod.number().describe('Total duration in milliseconds'),
  "total_heard_milliseconds": zod.number().describe('Total heard in milliseconds'),
  "total_engaged_percentage": zod.number().describe('Total engaged percentage'),
  "total_messages_posted": zod.number().describe('Total messages posted'),
  "total_users": zod.number().describe('Total users')
}).describe('Conversation stats'),
  "user_stats": zod.array(zod.object({
  "user_id": zod.string().describe('User unique ID'),
  "total_messages_posted": zod.number().describe('Total messages posted'),
  "total_sent_milliseconds": zod.number().describe('Total sent in milliseconds'),
  "total_heard_milliseconds": zod.number().describe('Total heard in milliseconds'),
  "total_engaged_percentage": zod.number().describe('Total engaged percentage'),
  "total_heard_messages": zod.number().describe('Total heard messages'),
  "total_unheard_messages": zod.number().describe('Total unheard messages')
})).describe('User stats')
}).optional().describe('Async Meeting Stats'),
  "created_at": zod.string().datetime({}),
  "last_updated_at": zod.string().datetime({}),
  "deleted_at": zod.string().datetime({}).optional()
}).optional(),
  "labels": zod.array(zod.object({
  "id": zod.string().describe('ID'),
  "name": zod.string().describe('Name'),
  "behavior": zod.enum(['removeOnListenStart', 'removeWhenHeard', 'persistent']).describe('Behavior'),
  "type": zod.enum(['personal', 'workspace', 'system', 'reaction']).describe('Type'),
  "creator_guid": zod.string().describe('Creator ID'),
  "space_guid": zod.string().optional().describe('Workspace ID'),
  "image_url": zod.string().optional().describe('Image URL'),
  "automatic_playlist": zod.boolean().optional().describe('Automatic Playlist'),
  "sort_order": zod.number().optional().describe('Sort Order')
})).optional()
})).optional().describe('List of 10 recent messages')
})


/**
 * @summary Get Message By ID
 */
export const getMessageByIdParams = zod.object({
  "id": zod.string()
})

export const getMessageByIdQueryParams = zod.object({
  "language": zod.string().optional().describe('Language (optional) - Original language will be used if not provided or not found.'),
  "fields": zod.string().optional().describe('Fields (optional) - Additional fields to include in the response. Possible values: conversation, creator, labels.')
})

export const getMessageByIdResponseMessageLanguageDefault = "english";

export const getMessageByIdResponse = zod.object({
  "message": zod.object({
  "id": zod.string().describe('ID'),
  "name": zod.string().optional().describe('Name'),
  "link": zod.string().describe('Link to Message'),
  "creator_id": zod.string().describe('Creator ID'),
  "conversation_id": zod.string().optional().describe('Conversation ID'),
  "workspace_id": zod.string().optional().describe('Workspace ID'),
  "created_at": zod.string().datetime({}),
  "last_updated_at": zod.string().datetime({}),
  "deleted_at": zod.string().datetime({}).optional(),
  "duration_ms": zod.number().describe('The length of the message in milliseconds'),
  "audio_url": zod.string().optional().describe('The URL for the message audio file'),
  "audio_stream_url": zod.string().optional().describe('The URL for the message audio stream'),
  "transcript": zod.string().optional().describe('Transcript of the message'),
  "ai_summary": zod.string().optional().describe('AI Summary generated of the message'),
  "waveform_url": zod.string().optional().describe('The URL for the message waveform image'),
  "reply_count": zod.number().describe('The number of replies to the message'),
  "parent_message_id": zod.string().optional().describe('Parent Message unique ID (only available for replies)'),
  "language": zod.string().default(getMessageByIdResponseMessageLanguageDefault).describe('Language for the message (Transcript, AI summary, Audio...)'),
  "status": zod.enum(['offline', 'paused', 'processing', 'scheduled', 'active', 'deleted', 'account-deleted', 'initializing', 'inprogress', 'canceled', 'failed']).describe('Current status of the Message'),
  "type": zod.enum(['channel', 'prerecorded', 'voicememo', 'stored', 'welcome']).describe('Type of the Message'),
  "attachments": zod.array(zod.object({
  "id": zod.string(),
  "creator_id": zod.string(),
  "created_at": zod.string().datetime({}),
  "type": zod.enum(['link', 'file', 'location']),
  "link": zod.string(),
  "active_begin": zod.string().datetime({}).optional(),
  "active_end": zod.string().datetime({}).optional(),
  "filename": zod.string().optional(),
  "mime_type": zod.string().optional(),
  "length_in_bytes": zod.number().optional(),
  "location": zod.object({

}).optional()
})).optional().describe('List of attachments for the message'),
  "share_link_id": zod.string().optional().describe('Share Link ID to a message'),
  "folder_id": zod.string().optional().describe('Folder ID where the message is stored')
}),
  "creator": zod.object({
  "id": zod.string().describe(' ID'),
  "link": zod.string().describe('Link to User'),
  "created_at": zod.string().datetime({}),
  "first_name": zod.string().describe('First Name'),
  "last_name": zod.string().optional().describe('Last Name'),
  "full_name": zod.string().describe('Full Name'),
  "image_url": zod.string().optional().describe('Image Url'),
  "emails": zod.array(zod.string()).optional().describe('List of emails (First one is the primary)'),
  "phones": zod.array(zod.string()).optional().describe('List of phones (First one is the primary)'),
  "languages": zod.array(zod.string()).optional().describe('List of languages (First one is the primary)')
}).optional(),
  "conversation": zod.object({
  "id": zod.string().describe('ID'),
  "link": zod.string().describe('Link to Conversation'),
  "name": zod.string().describe('Name'),
  "description": zod.string().optional().describe('Description'),
  "workspace_id": zod.string().describe('Workspace ID'),
  "workspace_name": zod.string().describe('Workspace Name'),
  "workspace_image_url": zod.string().optional().describe('Workspace Image Url'),
  "owner_id": zod.string().describe('owner unique ID'),
  "type": zod.enum(['directMessage', 'customerConversation', 'namedConversation', 'asyncMeeting']).describe('Type'),
  "visibility": zod.enum(['private', 'workspace', 'public']).describe('Visibility'),
  "total_messages": zod.number().describe('Total Messages'),
  "total_duration_ms": zod.number().describe('Total duration in milliseconds'),
  "image_url": zod.string().optional().describe('Image Url'),
  "is_private": zod.boolean().describe('Is Private Conversation'),
  "is_async": zod.boolean().describe('Is Async Conversation'),
  "async_stats": zod.object({
  "stats": zod.object({
  "total_duration_milliseconds": zod.number().describe('Total duration in milliseconds'),
  "total_heard_milliseconds": zod.number().describe('Total heard in milliseconds'),
  "total_engaged_percentage": zod.number().describe('Total engaged percentage'),
  "total_messages_posted": zod.number().describe('Total messages posted'),
  "total_users": zod.number().describe('Total users')
}).describe('Conversation stats'),
  "user_stats": zod.array(zod.object({
  "user_id": zod.string().describe('User unique ID'),
  "total_messages_posted": zod.number().describe('Total messages posted'),
  "total_sent_milliseconds": zod.number().describe('Total sent in milliseconds'),
  "total_heard_milliseconds": zod.number().describe('Total heard in milliseconds'),
  "total_engaged_percentage": zod.number().describe('Total engaged percentage'),
  "total_heard_messages": zod.number().describe('Total heard messages'),
  "total_unheard_messages": zod.number().describe('Total unheard messages')
})).describe('User stats')
}).optional().describe('Async Meeting Stats'),
  "created_at": zod.string().datetime({}),
  "last_updated_at": zod.string().datetime({}),
  "deleted_at": zod.string().datetime({}).optional()
}).optional(),
  "labels": zod.array(zod.object({
  "id": zod.string().describe('ID'),
  "name": zod.string().describe('Name'),
  "behavior": zod.enum(['removeOnListenStart', 'removeWhenHeard', 'persistent']).describe('Behavior'),
  "type": zod.enum(['personal', 'workspace', 'system', 'reaction']).describe('Type'),
  "creator_guid": zod.string().describe('Creator ID'),
  "space_guid": zod.string().optional().describe('Workspace ID'),
  "image_url": zod.string().optional().describe('Image URL'),
  "automatic_playlist": zod.boolean().optional().describe('Automatic Playlist'),
  "sort_order": zod.number().optional().describe('Sort Order')
})).optional()
})


/**
 * By default return most recent messages. The **maximum** allowed range between dates is **31 days**.
 * @summary List Messages
 */
export const listMessagesQueryPageDefault = 1;export const listMessagesQuerySizeDefault = 20;
export const listMessagesQuerySizeMax = 50;
export const listMessagesQuerySortDirectionDefault = "DESC";

export const listMessagesQueryParams = zod.object({
  "page": zod.number().min(1).default(listMessagesQueryPageDefault),
  "size": zod.number().min(1).max(listMessagesQuerySizeMax).default(listMessagesQuerySizeDefault).describe('Max number of results per page is: **50**'),
  "sort_direction": zod.enum(['ASC', 'DESC']).default(listMessagesQuerySortDirectionDefault).describe('The field used to sort results is **Creation Date**'),
  "start_date": zod.string().datetime({}).optional().describe('Start Date range'),
  "end_date": zod.string().datetime({}).optional().describe('End Date range'),
  "workspace_id": zod.string().optional().describe('Workspace ID (optional)'),
  "conversation_id": zod.string().optional().describe('Conversation ID (optional)'),
  "language": zod.string().optional().describe('Language (optional)'),
  "type": zod.enum(['channel', 'prerecorded', 'voicememo', 'stored', 'welcome']).optional().describe('Type (optional)'),
  "folder_id": zod.string().optional().describe('Folder ID (optional)'),
  "user_ids": zod.array(zod.string()).optional().describe('User IDs (optional). List of user IDs to filter messages by. If not provided, all users will be included.')
})

export const listMessagesResponsePageDefault = 1;export const listMessagesResponseSizeDefault = 20;
export const listMessagesResponseSizeMax = 50;
export const listMessagesResponseSortDirectionDefault = "DESC";export const listMessagesResponseResultsItemLanguageDefault = "english";

export const listMessagesResponse = zod.object({
  "page": zod.number().min(1).default(listMessagesResponsePageDefault),
  "size": zod.number().min(1).max(listMessagesResponseSizeMax).default(listMessagesResponseSizeDefault).describe('Max number of results per page is: **50**'),
  "sort_direction": zod.enum(['ASC', 'DESC']).default(listMessagesResponseSortDirectionDefault).describe('The field used to sort results is **Creation Date**'),
  "total": zod.number().describe('Total number of records by applied filters (if any)'),
  "results_count": zod.number().describe('Results count (paginated results)'),
  "has_next_page": zod.boolean().describe('If there is more data available (omitted by pagination)'),
  "filters": zod.object({
  "start_date": zod.string().datetime({}).optional().describe('Start Date range'),
  "end_date": zod.string().datetime({}).optional().describe('End Date range'),
  "workspace_id": zod.string().optional().describe('Workspace ID (optional)'),
  "conversation_id": zod.string().optional().describe('Conversation ID (optional)'),
  "language": zod.string().optional().describe('Language (optional)'),
  "type": zod.enum(['channel', 'prerecorded', 'voicememo', 'stored', 'welcome']).optional().describe('Type (optional)'),
  "folder_id": zod.string().optional().describe('Folder ID (optional)'),
  "user_ids": zod.array(zod.string()).optional().describe('User IDs (optional). List of user IDs to filter messages by. If not provided, all users will be included.')
}).optional().describe('Filters'),
  "results": zod.array(zod.object({
  "id": zod.string().describe('ID'),
  "name": zod.string().optional().describe('Name'),
  "link": zod.string().describe('Link to Message'),
  "creator_id": zod.string().describe('Creator ID'),
  "conversation_id": zod.string().optional().describe('Conversation ID'),
  "workspace_id": zod.string().optional().describe('Workspace ID'),
  "created_at": zod.string().datetime({}),
  "last_updated_at": zod.string().datetime({}),
  "deleted_at": zod.string().datetime({}).optional(),
  "duration_ms": zod.number().describe('The length of the message in milliseconds'),
  "audio_url": zod.string().optional().describe('The URL for the message audio file'),
  "audio_stream_url": zod.string().optional().describe('The URL for the message audio stream'),
  "transcript": zod.string().optional().describe('Transcript of the message'),
  "ai_summary": zod.string().optional().describe('AI Summary generated of the message'),
  "waveform_url": zod.string().optional().describe('The URL for the message waveform image'),
  "reply_count": zod.number().describe('The number of replies to the message'),
  "parent_message_id": zod.string().optional().describe('Parent Message unique ID (only available for replies)'),
  "language": zod.string().default(listMessagesResponseResultsItemLanguageDefault).describe('Language for the message (Transcript, AI summary, Audio...)'),
  "status": zod.enum(['offline', 'paused', 'processing', 'scheduled', 'active', 'deleted', 'account-deleted', 'initializing', 'inprogress', 'canceled', 'failed']).describe('Current status of the Message'),
  "type": zod.enum(['channel', 'prerecorded', 'voicememo', 'stored', 'welcome']).describe('Type of the Message'),
  "attachments": zod.array(zod.object({
  "id": zod.string(),
  "creator_id": zod.string(),
  "created_at": zod.string().datetime({}),
  "type": zod.enum(['link', 'file', 'location']),
  "link": zod.string(),
  "active_begin": zod.string().datetime({}).optional(),
  "active_end": zod.string().datetime({}).optional(),
  "filename": zod.string().optional(),
  "mime_type": zod.string().optional(),
  "length_in_bytes": zod.number().optional(),
  "location": zod.object({

}).optional()
})).optional().describe('List of attachments for the message'),
  "share_link_id": zod.string().optional().describe('Share Link ID to a message'),
  "folder_id": zod.string().optional().describe('Folder ID where the message is stored')
})).describe('List of Messages')
})


/**
 * Max number of links is **100** per API call. If you want to add more, should make another api call.
 * @summary Add Link Attachments to a message
 */
export const addLinkAttachmentsToMessageParams = zod.object({
  "id": zod.string()
})

export const addLinkAttachmentsToMessageBody = zod.object({
  "links": zod.array(zod.string()).describe('Array of links to be attached to the message')
})


/**
 * In order to create a Message, you must provide **transcript** or **link** attachments.
 * @summary Send a Message to a Conversation
 */
export const createConversationMessageParams = zod.object({
  "id": zod.string()
})

export const createConversationMessageBodyFromMessageTypeDefault = "NewMessage";

export const createConversationMessageBody = zod.object({
  "transcript": zod.string().optional().describe('The Message transcript will be used to generate audio using text-to-speech'),
  "links": zod.array(zod.string()).optional().describe('Array of links to be attached to the message'),
  "from_message_type": zod.enum(['PreRecorded', 'NewMessage', 'Forward']).default(createConversationMessageBodyFromMessageTypeDefault).describe('From Message type'),
  "from_message_id": zod.string().optional().describe('Message ID to be used as a base for the new message. (Optional only when from_message_type is NewMessage)')
})


/**
 * In order to create a Message, you must provide **transcript** or **link** attachments.
 * @summary Send a Direct Message to a User or a Group of Users
 */
export const sendDirectMessageBodyWorkspaceIdDefault = "personal";export const sendDirectMessageBodyFromMessageTypeDefault = "NewMessage";

export const sendDirectMessageBody = zod.object({
  "to": zod.object({
  "user_ids": zod.array(zod.string()).optional().describe('Array of user IDs to send the message to'),
  "emails": zod.array(zod.string()).optional().describe('Array of email addresses to send the message to')
}),
  "workspace_id": zod.string().default(sendDirectMessageBodyWorkspaceIdDefault).describe('The workspace ID to send the message to'),
  "transcript": zod.string().optional().describe('The Message transcript will be used to generate audio using text-to-speech'),
  "links": zod.array(zod.string()).optional().describe('Array of links to be attached to the message'),
  "from_message_type": zod.enum(['PreRecorded', 'NewMessage', 'Forward']).default(sendDirectMessageBodyFromMessageTypeDefault).describe('From Message type'),
  "from_message_id": zod.string().optional().describe('Message ID to be used as a base for the new message. (Optional only when from_message_type is NewMessage)')
})


/**
 * In order to create a voicememo message, you must provide **transcript** or **link** attachments.
 * @summary Create a Voicememo Message
 */
export const createVoiceMemoMessageBody = zod.object({
  "transcript": zod.string().optional().describe('The Message transcript will be used to generate audio using text-to-speech'),
  "links": zod.array(zod.string()).optional().describe('Array of links to be attached to the message'),
  "folder_id": zod.string().optional().describe('Folder ID (not allowed when workspace_id specified is different from the folder_id)'),
  "workspace_id": zod.string().optional().describe('Workspace ID (not allowed when folder_id specified is different from the folder_id)')
})


/**
 * It's required to inform one of (**email**, **phone**)
 * @summary Search user by email or phone
 */
export const searchUserQueryParams = zod.object({
  "email": zod.string().optional().describe('Email Address'),
  "phone": zod.string().optional().describe('Phone Number')
})

export const searchUserResponse = zod.object({
  "id": zod.string().describe(' ID'),
  "link": zod.string().describe('Link to User'),
  "created_at": zod.string().datetime({}),
  "first_name": zod.string().describe('First Name'),
  "last_name": zod.string().optional().describe('Last Name'),
  "full_name": zod.string().describe('Full Name'),
  "image_url": zod.string().optional().describe('Image Url'),
  "emails": zod.array(zod.string()).optional().describe('List of emails (First one is the primary)'),
  "phones": zod.array(zod.string()).optional().describe('List of phones (First one is the primary)'),
  "languages": zod.array(zod.string()).optional().describe('List of languages (First one is the primary)')
})


/**
 * @summary Search users by their emails, phones or IDs
 */
export const searchUsersBody = zod.object({
  "emails": zod.array(zod.string()).optional().describe('Email Addresses'),
  "phones": zod.array(zod.string()).optional().describe('Phone Numbers'),
  "ids": zod.array(zod.string()).optional().describe('User IDs')
})

export const searchUsersResponseItem = zod.object({
  "id": zod.string().describe(' ID'),
  "link": zod.string().describe('Link to User'),
  "created_at": zod.string().datetime({}),
  "first_name": zod.string().describe('First Name'),
  "last_name": zod.string().optional().describe('Last Name'),
  "full_name": zod.string().describe('Full Name'),
  "image_url": zod.string().optional().describe('Image Url'),
  "emails": zod.array(zod.string()).optional().describe('List of emails (First one is the primary)'),
  "phones": zod.array(zod.string()).optional().describe('List of phones (First one is the primary)'),
  "languages": zod.array(zod.string()).optional().describe('List of languages (First one is the primary)')
})
export const searchUsersResponse = zod.array(searchUsersResponseItem)


/**
 * @summary Get User By ID
 */
export const getUserByIdParams = zod.object({
  "id": zod.string()
})

export const getUserByIdResponse = zod.object({
  "id": zod.string().describe(' ID'),
  "link": zod.string().describe('Link to User'),
  "created_at": zod.string().datetime({}),
  "first_name": zod.string().describe('First Name'),
  "last_name": zod.string().optional().describe('Last Name'),
  "full_name": zod.string().describe('Full Name'),
  "image_url": zod.string().optional().describe('Image Url'),
  "emails": zod.array(zod.string()).optional().describe('List of emails (First one is the primary)'),
  "phones": zod.array(zod.string()).optional().describe('List of phones (First one is the primary)'),
  "languages": zod.array(zod.string()).optional().describe('List of languages (First one is the primary)')
})


/**
 * @summary Get all user conversations (Only _id and name available
 */
export const getAllConversationsResponse = zod.object({
  "results_count": zod.number().describe('Results count'),
  "results": zod.array(zod.object({
  "id": zod.string().describe('ID'),
  "name": zod.string().describe('Name'),
  "workspace_id": zod.string().describe('Workspace ID'),
  "type": zod.enum(['directMessage', 'customerConversation', 'namedConversation', 'asyncMeeting']).describe('Type')
})).optional()
})


/**
 * @summary Get a conversation by id
 */
export const getConversationByIdParams = zod.object({
  "id": zod.string()
})

export const getConversationByIdResponse = zod.object({
  "id": zod.string().describe('ID'),
  "link": zod.string().describe('Link to Conversation'),
  "name": zod.string().describe('Name'),
  "description": zod.string().optional().describe('Description'),
  "workspace_id": zod.string().describe('Workspace ID'),
  "workspace_name": zod.string().describe('Workspace Name'),
  "workspace_image_url": zod.string().optional().describe('Workspace Image Url'),
  "owner_id": zod.string().describe('owner unique ID'),
  "type": zod.enum(['directMessage', 'customerConversation', 'namedConversation', 'asyncMeeting']).describe('Type'),
  "visibility": zod.enum(['private', 'workspace', 'public']).describe('Visibility'),
  "total_messages": zod.number().describe('Total Messages'),
  "total_duration_ms": zod.number().describe('Total duration in milliseconds'),
  "image_url": zod.string().optional().describe('Image Url'),
  "is_private": zod.boolean().describe('Is Private Conversation'),
  "is_async": zod.boolean().describe('Is Async Conversation'),
  "async_stats": zod.object({
  "stats": zod.object({
  "total_duration_milliseconds": zod.number().describe('Total duration in milliseconds'),
  "total_heard_milliseconds": zod.number().describe('Total heard in milliseconds'),
  "total_engaged_percentage": zod.number().describe('Total engaged percentage'),
  "total_messages_posted": zod.number().describe('Total messages posted'),
  "total_users": zod.number().describe('Total users')
}).describe('Conversation stats'),
  "user_stats": zod.array(zod.object({
  "user_id": zod.string().describe('User unique ID'),
  "total_messages_posted": zod.number().describe('Total messages posted'),
  "total_sent_milliseconds": zod.number().describe('Total sent in milliseconds'),
  "total_heard_milliseconds": zod.number().describe('Total heard in milliseconds'),
  "total_engaged_percentage": zod.number().describe('Total engaged percentage'),
  "total_heard_messages": zod.number().describe('Total heard messages'),
  "total_unheard_messages": zod.number().describe('Total unheard messages')
})).describe('User stats')
}).optional().describe('Async Meeting Stats'),
  "created_at": zod.string().datetime({}),
  "last_updated_at": zod.string().datetime({}),
  "deleted_at": zod.string().datetime({}).optional()
})


/**
 * @summary Get Conversation Users
 */
export const getConversationUsersParams = zod.object({
  "id": zod.string()
})

export const getConversationUsersResponseItem = zod.object({
  "id": zod.string().describe(' ID'),
  "link": zod.string().describe('Link to User'),
  "created_at": zod.string().datetime({}),
  "first_name": zod.string().describe('First Name'),
  "last_name": zod.string().optional().describe('Last Name'),
  "full_name": zod.string().describe('Full Name'),
  "image_url": zod.string().optional().describe('Image Url'),
  "emails": zod.array(zod.string()).optional().describe('List of emails (First one is the primary)'),
  "phones": zod.array(zod.string()).optional().describe('List of phones (First one is the primary)'),
  "languages": zod.array(zod.string()).optional().describe('List of languages (First one is the primary)')
})
export const getConversationUsersResponse = zod.array(getConversationUsersResponseItem)


/**
 * @summary Get all Workspaces that user has access to with basic info
 */
export const getAllWorkspacesWithBasicInfoResponseItem = zod.object({
  "id": zod.string(),
  "name": zod.string()
})
export const getAllWorkspacesWithBasicInfoResponse = zod.array(getAllWorkspacesWithBasicInfoResponseItem)


/**
 * @summary Get Sample AI Responses for a System AI Prompt
 */
export const getAiSystemPromptResponseParams = zod.object({
  "prompt_id": zod.string()
})


/**
 * @summary Get all root Folders
 */
export const getAllRootFoldersQueryIncludeAllTreeDefault = false;export const getAllRootFoldersQuerySortDirectionDefault = "ASC";export const getAllRootFoldersQuerySortByDefault = "name";

export const getAllRootFoldersQueryParams = zod.object({
  "type": zod.enum(['voicememo', 'prerecorded']).describe('Folder Type'),
  "include_all_tree": zod.boolean().optional().describe('Return all folders tree'),
  "workspace_id": zod.string().optional().describe('Workspace ID'),
  "sort_direction": zod.enum(['ASC', 'DESC']).default(getAllRootFoldersQuerySortDirectionDefault).describe('Sort order direction'),
  "sort_by": zod.enum(['created_at', 'last_updated_at', 'name']).default(getAllRootFoldersQuerySortByDefault).describe('Field to sort by')
})

export const getAllRootFoldersResponseIncludeAllTreeDefault = false;export const getAllRootFoldersResponseSortDirectionDefault = "ASC";export const getAllRootFoldersResponseSortByDefault = "name";export const getAllRootFoldersResponseResultsItemTotalNestedFoldersCountDefault = 0;export const getAllRootFoldersResponseResultsItemTotalNestedMessagesCountDefault = 0;export const getAllRootFoldersResponseResultsItemSubfoldersItemTotalNestedFoldersCountDefault = 0;export const getAllRootFoldersResponseResultsItemSubfoldersItemTotalNestedMessagesCountDefault = 0;

export const getAllRootFoldersResponse = zod.object({
  "type": zod.enum(['voicememo', 'prerecorded']).describe('Folder Type'),
  "include_all_tree": zod.boolean().optional().describe('Return all folders tree'),
  "workspace_id": zod.string().optional().describe('Workspace ID'),
  "sort_direction": zod.enum(['ASC', 'DESC']).default(getAllRootFoldersResponseSortDirectionDefault).describe('Sort order direction'),
  "sort_by": zod.enum(['created_at', 'last_updated_at', 'name']).default(getAllRootFoldersResponseSortByDefault).describe('Field to sort by'),
  "results": zod.array(zod.object({
  "id": zod.string().describe('Unique Identifier'),
  "name": zod.string().describe('Name'),
  "creator_id": zod.string().describe('Creator'),
  "parent_folder_id": zod.string().optional().describe('Parent Folder ID'),
  "subfolder_ids": zod.array(zod.string()).optional().describe('List of Subfolder IDs'),
  "message_ids": zod.array(zod.string()).optional().describe('List of Message IDs'),
  "path": zod.array(zod.string()).optional().describe('Ordered List of all folders in the path from root to this folder'),
  "total_nested_folders_count": zod.number().describe('Total count for all Nested Folders'),
  "total_nested_messages_count": zod.number().describe('Total count for all Nested Messages'),
  "type": zod.enum(['voicememo', 'prerecorded']).describe('Folder type'),
  "workspace_id": zod.string().describe('Workspace ID where folder belongs to'),
  "created_at": zod.string().datetime({}),
  "last_updated_at": zod.string().datetime({}),
  "deleted_at": zod.string().datetime({}).optional(),
  "subfolders": zod.array(zod.object({
  "id": zod.string().describe('Unique Identifier'),
  "name": zod.string().describe('Name'),
  "creator_id": zod.string().describe('Creator'),
  "parent_folder_id": zod.string().optional().describe('Parent Folder ID'),
  "subfolder_ids": zod.array(zod.string()).optional().describe('List of Subfolder IDs'),
  "message_ids": zod.array(zod.string()).optional().describe('List of Message IDs'),
  "path": zod.array(zod.string()).optional().describe('Ordered List of all folders in the path from root to this folder'),
  "total_nested_folders_count": zod.number().describe('Total count for all Nested Folders'),
  "total_nested_messages_count": zod.number().describe('Total count for all Nested Messages'),
  "type": zod.enum(['voicememo', 'prerecorded']).describe('Folder type'),
  "workspace_id": zod.string().describe('Workspace ID where folder belongs to'),
  "created_at": zod.string().datetime({}),
  "last_updated_at": zod.string().datetime({}),
  "deleted_at": zod.string().datetime({}).optional()
})).optional().describe('Subfolders (only one deep level)')
})).optional().describe('List of Folders')
})


/**
 * @summary Create a new Folder
 */
export const createFolderBody = zod.object({
  "name": zod.string().describe('Name of the Folder'),
  "type": zod.enum(['voicememo', 'prerecorded']).describe('Folder type'),
  "workspace_id": zod.string().describe('Workspace ID'),
  "parent_folder_id": zod.string().optional().describe('Parent Folder ID')
})

export const createFolderResponseTotalNestedFoldersCountDefault = 0;export const createFolderResponseTotalNestedMessagesCountDefault = 0;export const createFolderResponseSubfoldersItemTotalNestedFoldersCountDefault = 0;export const createFolderResponseSubfoldersItemTotalNestedMessagesCountDefault = 0;

export const createFolderResponse = zod.object({
  "id": zod.string().describe('Unique Identifier'),
  "name": zod.string().describe('Name'),
  "creator_id": zod.string().describe('Creator'),
  "parent_folder_id": zod.string().optional().describe('Parent Folder ID'),
  "subfolder_ids": zod.array(zod.string()).optional().describe('List of Subfolder IDs'),
  "message_ids": zod.array(zod.string()).optional().describe('List of Message IDs'),
  "path": zod.array(zod.string()).optional().describe('Ordered List of all folders in the path from root to this folder'),
  "total_nested_folders_count": zod.number().describe('Total count for all Nested Folders'),
  "total_nested_messages_count": zod.number().describe('Total count for all Nested Messages'),
  "type": zod.enum(['voicememo', 'prerecorded']).describe('Folder type'),
  "workspace_id": zod.string().describe('Workspace ID where folder belongs to'),
  "created_at": zod.string().datetime({}),
  "last_updated_at": zod.string().datetime({}),
  "deleted_at": zod.string().datetime({}).optional(),
  "subfolders": zod.array(zod.object({
  "id": zod.string().describe('Unique Identifier'),
  "name": zod.string().describe('Name'),
  "creator_id": zod.string().describe('Creator'),
  "parent_folder_id": zod.string().optional().describe('Parent Folder ID'),
  "subfolder_ids": zod.array(zod.string()).optional().describe('List of Subfolder IDs'),
  "message_ids": zod.array(zod.string()).optional().describe('List of Message IDs'),
  "path": zod.array(zod.string()).optional().describe('Ordered List of all folders in the path from root to this folder'),
  "total_nested_folders_count": zod.number().describe('Total count for all Nested Folders'),
  "total_nested_messages_count": zod.number().describe('Total count for all Nested Messages'),
  "type": zod.enum(['voicememo', 'prerecorded']).describe('Folder type'),
  "workspace_id": zod.string().describe('Workspace ID where folder belongs to'),
  "created_at": zod.string().datetime({}),
  "last_updated_at": zod.string().datetime({}),
  "deleted_at": zod.string().datetime({}).optional()
})).optional().describe('Subfolders (only one deep level)')
})


/**
 * @summary Get count of all folders, messages and message_ids not in folders grouped by workspace
 */
export const getCountsGroupedByWorkspaceQueryParams = zod.object({
  "type": zod.enum(['voicememo', 'prerecorded']).describe('Folder Type'),
  "workspace_id": zod.string().optional().describe('Workspace ID')
})

export const getCountsGroupedByWorkspaceResponseRootFoldersItemTotalNestedFoldersCountDefault = 0;export const getCountsGroupedByWorkspaceResponseRootFoldersItemTotalNestedMessagesCountDefault = 0;export const getCountsGroupedByWorkspaceResponseRootFoldersItemSubfoldersItemTotalNestedFoldersCountDefault = 0;export const getCountsGroupedByWorkspaceResponseRootFoldersItemSubfoldersItemTotalNestedMessagesCountDefault = 0;

export const getCountsGroupedByWorkspaceResponseItem = zod.object({
  "workspace_id": zod.string(),
  "total_folders": zod.number(),
  "total_messages": zod.number(),
  "message_ids_without_folder": zod.array(zod.string()).optional().describe('List of Messages without Folder'),
  "root_folders": zod.array(zod.object({
  "id": zod.string().describe('Unique Identifier'),
  "name": zod.string().describe('Name'),
  "creator_id": zod.string().describe('Creator'),
  "parent_folder_id": zod.string().optional().describe('Parent Folder ID'),
  "subfolder_ids": zod.array(zod.string()).optional().describe('List of Subfolder IDs'),
  "message_ids": zod.array(zod.string()).optional().describe('List of Message IDs'),
  "path": zod.array(zod.string()).optional().describe('Ordered List of all folders in the path from root to this folder'),
  "total_nested_folders_count": zod.number().describe('Total count for all Nested Folders'),
  "total_nested_messages_count": zod.number().describe('Total count for all Nested Messages'),
  "type": zod.enum(['voicememo', 'prerecorded']).describe('Folder type'),
  "workspace_id": zod.string().describe('Workspace ID where folder belongs to'),
  "created_at": zod.string().datetime({}),
  "last_updated_at": zod.string().datetime({}),
  "deleted_at": zod.string().datetime({}).optional(),
  "subfolders": zod.array(zod.object({
  "id": zod.string().describe('Unique Identifier'),
  "name": zod.string().describe('Name'),
  "creator_id": zod.string().describe('Creator'),
  "parent_folder_id": zod.string().optional().describe('Parent Folder ID'),
  "subfolder_ids": zod.array(zod.string()).optional().describe('List of Subfolder IDs'),
  "message_ids": zod.array(zod.string()).optional().describe('List of Message IDs'),
  "path": zod.array(zod.string()).optional().describe('Ordered List of all folders in the path from root to this folder'),
  "total_nested_folders_count": zod.number().describe('Total count for all Nested Folders'),
  "total_nested_messages_count": zod.number().describe('Total count for all Nested Messages'),
  "type": zod.enum(['voicememo', 'prerecorded']).describe('Folder type'),
  "workspace_id": zod.string().describe('Workspace ID where folder belongs to'),
  "created_at": zod.string().datetime({}),
  "last_updated_at": zod.string().datetime({}),
  "deleted_at": zod.string().datetime({}).optional()
})).optional().describe('Subfolders (only one deep level)')
})).optional().describe('List of Root Folders'),
  "last_updated_at": zod.string().datetime({})
})
export const getCountsGroupedByWorkspaceResponse = zod.array(getCountsGroupedByWorkspaceResponseItem)


/**
 * @summary Get Folder with Messages
 */
export const getFolderMessagesParams = zod.object({
  "id": zod.string()
})

export const getFolderMessagesResponseFolderTotalNestedFoldersCountDefault = 0;export const getFolderMessagesResponseFolderTotalNestedMessagesCountDefault = 0;export const getFolderMessagesResponseFolderSubfoldersItemTotalNestedFoldersCountDefault = 0;export const getFolderMessagesResponseFolderSubfoldersItemTotalNestedMessagesCountDefault = 0;export const getFolderMessagesResponseMessagesItemSocketDisconnectsWhileStreamingDefault = 0;

export const getFolderMessagesResponse = zod.object({
  "folder": zod.object({
  "id": zod.string().describe('Unique Identifier'),
  "name": zod.string().describe('Name'),
  "creator_id": zod.string().describe('Creator'),
  "parent_folder_id": zod.string().optional().describe('Parent Folder ID'),
  "subfolder_ids": zod.array(zod.string()).optional().describe('List of Subfolder IDs'),
  "message_ids": zod.array(zod.string()).optional().describe('List of Message IDs'),
  "path": zod.array(zod.string()).optional().describe('Ordered List of all folders in the path from root to this folder'),
  "total_nested_folders_count": zod.number().describe('Total count for all Nested Folders'),
  "total_nested_messages_count": zod.number().describe('Total count for all Nested Messages'),
  "type": zod.enum(['voicememo', 'prerecorded']).describe('Folder type'),
  "workspace_id": zod.string().describe('Workspace ID where folder belongs to'),
  "created_at": zod.string().datetime({}),
  "last_updated_at": zod.string().datetime({}),
  "deleted_at": zod.string().datetime({}).optional(),
  "subfolders": zod.array(zod.object({
  "id": zod.string().describe('Unique Identifier'),
  "name": zod.string().describe('Name'),
  "creator_id": zod.string().describe('Creator'),
  "parent_folder_id": zod.string().optional().describe('Parent Folder ID'),
  "subfolder_ids": zod.array(zod.string()).optional().describe('List of Subfolder IDs'),
  "message_ids": zod.array(zod.string()).optional().describe('List of Message IDs'),
  "path": zod.array(zod.string()).optional().describe('Ordered List of all folders in the path from root to this folder'),
  "total_nested_folders_count": zod.number().describe('Total count for all Nested Folders'),
  "total_nested_messages_count": zod.number().describe('Total count for all Nested Messages'),
  "type": zod.enum(['voicememo', 'prerecorded']).describe('Folder type'),
  "workspace_id": zod.string().describe('Workspace ID where folder belongs to'),
  "created_at": zod.string().datetime({}),
  "last_updated_at": zod.string().datetime({}),
  "deleted_at": zod.string().datetime({}).optional()
})).optional().describe('Subfolders (only one deep level)')
}).describe('Folder'),
  "messages": zod.array(zod.object({
  "message_id": zod.string(),
  "creator_id": zod.string(),
  "created_at": zod.string().datetime({}),
  "deleted_at": zod.string().datetime({}).nullish(),
  "last_updated_at": zod.string().datetime({}),
  "workspace_ids": zod.array(zod.string()),
  "channel_ids": zod.array(zod.string()),
  "parent_message_id": zod.string().nullish(),
  "heard_ms": zod.number().nullish().describe('The number of ms of audio listened to by the user requesting the message'),
  "utm_data": zod.object({
  "utm_source": zod.string().optional(),
  "utm_medium": zod.string().optional(),
  "utm_campaign": zod.string().optional(),
  "utm_term": zod.string().optional(),
  "utm_content": zod.string().optional()
}).nullish(),
  "attachments": zod.array(zod.object({
  "id": zod.string(),
  "creator_id": zod.string(),
  "created_at": zod.string().datetime({}),
  "type": zod.enum(['link', 'file', 'location']),
  "link": zod.string(),
  "active_begin": zod.string().datetime({}).optional(),
  "active_end": zod.string().datetime({}).optional(),
  "filename": zod.string().optional(),
  "mime_type": zod.string().optional(),
  "length_in_bytes": zod.number().optional(),
  "location": zod.object({

}).optional()
})),
  "notes": zod.string(),
  "notify": zod.boolean().describe('Has the logged in user cleared the notification for this message'),
  "last_heard_update": zod.string().datetime({}).describe('Last time we listened/updated notify bit'),
  "reaction_summary": zod.object({
  "reaction_counts": zod.record(zod.string(), zod.number()),
  "top_user_reactions": zod.array(zod.object({
  "user_id": zod.string(),
  "reaction_id": zod.string()
}))
}),
  "name": zod.string().nullish(),
  "is_text_message": zod.boolean(),
  "status": zod.enum(['offline', 'paused', 'processing', 'scheduled', 'active', 'deleted', 'account-deleted', 'initializing', 'inprogress', 'canceled', 'failed']),
  "label_ids": zod.array(zod.string()),
  "audio_models": zod.array(zod.object({
  "_id": zod.string(),
  "url": zod.string(),
  "extension": zod.string().nullable(),
  "streaming": zod.boolean(),
  "language": zod.string(),
  "duration_ms": zod.number(),
  "waveform_percentages": zod.array(zod.number()),
  "is_original_audio": zod.boolean()
})),
  "text_models": zod.array(zod.object({
  "type": zod.enum(['transcript', 'transcript_with_timecode', 'summary', 'topic', 'bullet_list']),
  "audio_id": zod.string().nullable(),
  "language_id": zod.string(),
  "value": zod.string(),
  "timecodes": zod.array(zod.object({
  "t": zod.string().describe('The text'),
  "s": zod.number().describe('The start time in ms'),
  "e": zod.number().describe('The end time in ms')
}))
})),
  "source_message_id": zod.string().nullable(),
  "cache_key": zod.string(),
  "audio_delivery": zod.enum(['recording', 'streaming']),
  "users_not_allowed_to_receive_notifications": zod.array(zod.object({
  "user_id": zod.string(),
  "phone": zod.string()
})).optional(),
  "users_not_allowed_to_receive_notifications_v2": zod.array(zod.object({
  "user_id": zod.string(),
  "phone": zod.string().nullish(),
  "email": zod.string().nullish()
})).optional(),
  "duration_ms": zod.number().describe('The length of the message in milliseconds'),
  "total_heard_ms": zod.number().describe('The number of ms of audio listened to by all users'),
  "notified_users": zod.number().describe('Then number of users who have a notification for this message and have not listened to the audio.'),
  "users_caught_up": zod.enum(['all', 'some', 'none']).describe('The number of users that listened to the audio or removed the notification'),
  "forward_id": zod.string().nullish().describe('The ID of a forwarded message (Deprecated, for new implementations we should start using share_link_id'),
  "share_link_id": zod.string().nullish().describe('The ID of a Share Link to a message'),
  "stream_key": zod.string().nullish().describe('The stream key used to add audio to the message'),
  "socket_disconnects_while_streaming": zod.number().describe('The number of times the socket disconnected while the creator was sending audio'),
  "type": zod.enum(['channel', 'prerecorded', 'voicememo', 'stored', 'welcome']).nullable().describe('Message type'),
  "channel_sequence": zod.number().describe('The sequencial id of the message within the channel'),
  "last_heard_at": zod.string().datetime({}).describe('The last time anyone listened or cleared notified on this message'),
  "folder_id": zod.string().nullish().describe('Folder ID, only present when the message type is one of: voicememo,prerecorded')
})).optional().describe('List of Messages')
})


/**
 * @summary Get Folder by ID
 */
export const getFolderByIdParams = zod.object({
  "id": zod.string()
})

export const getFolderByIdQueryIncludeFirstLevelTreeDefault = false;export const getFolderByIdQueryDirectionDefault = "newer";

export const getFolderByIdQueryParams = zod.object({
  "include_first_level_tree": zod.boolean().optional().describe('Defines if the first level of the folder tree should be returned'),
  "direction": zod.enum(['older', 'newer']).default(getFolderByIdQueryDirectionDefault).describe('Direction of the results (newer or older)'),
  "date": zod.string().datetime({}).nullish().describe('Return only Subfolders updated based on the date and direction (must inform include_first_level_tree = true)')
})

export const getFolderByIdResponseTotalNestedFoldersCountDefault = 0;export const getFolderByIdResponseTotalNestedMessagesCountDefault = 0;export const getFolderByIdResponseSubfoldersItemTotalNestedFoldersCountDefault = 0;export const getFolderByIdResponseSubfoldersItemTotalNestedMessagesCountDefault = 0;

export const getFolderByIdResponse = zod.object({
  "id": zod.string().describe('Unique Identifier'),
  "name": zod.string().describe('Name'),
  "creator_id": zod.string().describe('Creator'),
  "parent_folder_id": zod.string().optional().describe('Parent Folder ID'),
  "subfolder_ids": zod.array(zod.string()).optional().describe('List of Subfolder IDs'),
  "message_ids": zod.array(zod.string()).optional().describe('List of Message IDs'),
  "path": zod.array(zod.string()).optional().describe('Ordered List of all folders in the path from root to this folder'),
  "total_nested_folders_count": zod.number().describe('Total count for all Nested Folders'),
  "total_nested_messages_count": zod.number().describe('Total count for all Nested Messages'),
  "type": zod.enum(['voicememo', 'prerecorded']).describe('Folder type'),
  "workspace_id": zod.string().describe('Workspace ID where folder belongs to'),
  "created_at": zod.string().datetime({}),
  "last_updated_at": zod.string().datetime({}),
  "deleted_at": zod.string().datetime({}).optional(),
  "subfolders": zod.array(zod.object({
  "id": zod.string().describe('Unique Identifier'),
  "name": zod.string().describe('Name'),
  "creator_id": zod.string().describe('Creator'),
  "parent_folder_id": zod.string().optional().describe('Parent Folder ID'),
  "subfolder_ids": zod.array(zod.string()).optional().describe('List of Subfolder IDs'),
  "message_ids": zod.array(zod.string()).optional().describe('List of Message IDs'),
  "path": zod.array(zod.string()).optional().describe('Ordered List of all folders in the path from root to this folder'),
  "total_nested_folders_count": zod.number().describe('Total count for all Nested Folders'),
  "total_nested_messages_count": zod.number().describe('Total count for all Nested Messages'),
  "type": zod.enum(['voicememo', 'prerecorded']).describe('Folder type'),
  "workspace_id": zod.string().describe('Workspace ID where folder belongs to'),
  "created_at": zod.string().datetime({}),
  "last_updated_at": zod.string().datetime({}),
  "deleted_at": zod.string().datetime({}).optional()
})).optional().describe('Subfolders (only one deep level)')
})


/**
 * @summary Update Folder Name
 */
export const updateFolderNameParams = zod.object({
  "id": zod.string()
})

export const updateFolderNameBody = zod.object({
  "name": zod.string().describe('New Folder Name')
})

export const updateFolderNameResponseTotalNestedFoldersCountDefault = 0;export const updateFolderNameResponseTotalNestedMessagesCountDefault = 0;export const updateFolderNameResponseSubfoldersItemTotalNestedFoldersCountDefault = 0;export const updateFolderNameResponseSubfoldersItemTotalNestedMessagesCountDefault = 0;

export const updateFolderNameResponse = zod.object({
  "id": zod.string().describe('Unique Identifier'),
  "name": zod.string().describe('Name'),
  "creator_id": zod.string().describe('Creator'),
  "parent_folder_id": zod.string().optional().describe('Parent Folder ID'),
  "subfolder_ids": zod.array(zod.string()).optional().describe('List of Subfolder IDs'),
  "message_ids": zod.array(zod.string()).optional().describe('List of Message IDs'),
  "path": zod.array(zod.string()).optional().describe('Ordered List of all folders in the path from root to this folder'),
  "total_nested_folders_count": zod.number().describe('Total count for all Nested Folders'),
  "total_nested_messages_count": zod.number().describe('Total count for all Nested Messages'),
  "type": zod.enum(['voicememo', 'prerecorded']).describe('Folder type'),
  "workspace_id": zod.string().describe('Workspace ID where folder belongs to'),
  "created_at": zod.string().datetime({}),
  "last_updated_at": zod.string().datetime({}),
  "deleted_at": zod.string().datetime({}).optional(),
  "subfolders": zod.array(zod.object({
  "id": zod.string().describe('Unique Identifier'),
  "name": zod.string().describe('Name'),
  "creator_id": zod.string().describe('Creator'),
  "parent_folder_id": zod.string().optional().describe('Parent Folder ID'),
  "subfolder_ids": zod.array(zod.string()).optional().describe('List of Subfolder IDs'),
  "message_ids": zod.array(zod.string()).optional().describe('List of Message IDs'),
  "path": zod.array(zod.string()).optional().describe('Ordered List of all folders in the path from root to this folder'),
  "total_nested_folders_count": zod.number().describe('Total count for all Nested Folders'),
  "total_nested_messages_count": zod.number().describe('Total count for all Nested Messages'),
  "type": zod.enum(['voicememo', 'prerecorded']).describe('Folder type'),
  "workspace_id": zod.string().describe('Workspace ID where folder belongs to'),
  "created_at": zod.string().datetime({}),
  "last_updated_at": zod.string().datetime({}),
  "deleted_at": zod.string().datetime({}).optional()
})).optional().describe('Subfolders (only one deep level)')
})


/**
 * @summary Delete Folder and all subfolders and messages in nested folders
 */
export const deleteFolderParams = zod.object({
  "id": zod.string()
})


/**
 * Only allowed to move messages of type: voicememo,prerecorded.
 * @summary Move a message into specific Folder or into a Workspace
 */
export const addMessageToFolderOrWorkspaceBody = zod.object({
  "message_id": zod.string().describe('Only allowed to add messages of type: voicememo,prerecorded'),
  "workspace_id": zod.string().optional().describe('Workspace ID'),
  "folder_id": zod.string().optional().describe('Folder ID')
})

export const addMessageToFolderOrWorkspaceResponseSocketDisconnectsWhileStreamingDefault = 0;

export const addMessageToFolderOrWorkspaceResponse = zod.object({
  "message_id": zod.string(),
  "creator_id": zod.string(),
  "created_at": zod.string().datetime({}),
  "deleted_at": zod.string().datetime({}).nullish(),
  "last_updated_at": zod.string().datetime({}),
  "workspace_ids": zod.array(zod.string()),
  "channel_ids": zod.array(zod.string()),
  "parent_message_id": zod.string().nullish(),
  "heard_ms": zod.number().nullish().describe('The number of ms of audio listened to by the user requesting the message'),
  "utm_data": zod.object({
  "utm_source": zod.string().optional(),
  "utm_medium": zod.string().optional(),
  "utm_campaign": zod.string().optional(),
  "utm_term": zod.string().optional(),
  "utm_content": zod.string().optional()
}).nullish(),
  "attachments": zod.array(zod.object({
  "id": zod.string(),
  "creator_id": zod.string(),
  "created_at": zod.string().datetime({}),
  "type": zod.enum(['link', 'file', 'location']),
  "link": zod.string(),
  "active_begin": zod.string().datetime({}).optional(),
  "active_end": zod.string().datetime({}).optional(),
  "filename": zod.string().optional(),
  "mime_type": zod.string().optional(),
  "length_in_bytes": zod.number().optional(),
  "location": zod.object({

}).optional()
})),
  "notes": zod.string(),
  "notify": zod.boolean().describe('Has the logged in user cleared the notification for this message'),
  "last_heard_update": zod.string().datetime({}).describe('Last time we listened/updated notify bit'),
  "reaction_summary": zod.object({
  "reaction_counts": zod.record(zod.string(), zod.number()),
  "top_user_reactions": zod.array(zod.object({
  "user_id": zod.string(),
  "reaction_id": zod.string()
}))
}),
  "name": zod.string().nullish(),
  "is_text_message": zod.boolean(),
  "status": zod.enum(['offline', 'paused', 'processing', 'scheduled', 'active', 'deleted', 'account-deleted', 'initializing', 'inprogress', 'canceled', 'failed']),
  "label_ids": zod.array(zod.string()),
  "audio_models": zod.array(zod.object({
  "_id": zod.string(),
  "url": zod.string(),
  "extension": zod.string().nullable(),
  "streaming": zod.boolean(),
  "language": zod.string(),
  "duration_ms": zod.number(),
  "waveform_percentages": zod.array(zod.number()),
  "is_original_audio": zod.boolean()
})),
  "text_models": zod.array(zod.object({
  "type": zod.enum(['transcript', 'transcript_with_timecode', 'summary', 'topic', 'bullet_list']),
  "audio_id": zod.string().nullable(),
  "language_id": zod.string(),
  "value": zod.string(),
  "timecodes": zod.array(zod.object({
  "t": zod.string().describe('The text'),
  "s": zod.number().describe('The start time in ms'),
  "e": zod.number().describe('The end time in ms')
}))
})),
  "source_message_id": zod.string().nullable(),
  "cache_key": zod.string(),
  "audio_delivery": zod.enum(['recording', 'streaming']),
  "users_not_allowed_to_receive_notifications": zod.array(zod.object({
  "user_id": zod.string(),
  "phone": zod.string()
})).optional(),
  "users_not_allowed_to_receive_notifications_v2": zod.array(zod.object({
  "user_id": zod.string(),
  "phone": zod.string().nullish(),
  "email": zod.string().nullish()
})).optional(),
  "duration_ms": zod.number().describe('The length of the message in milliseconds'),
  "total_heard_ms": zod.number().describe('The number of ms of audio listened to by all users'),
  "notified_users": zod.number().describe('Then number of users who have a notification for this message and have not listened to the audio.'),
  "users_caught_up": zod.enum(['all', 'some', 'none']).describe('The number of users that listened to the audio or removed the notification'),
  "forward_id": zod.string().nullish().describe('The ID of a forwarded message (Deprecated, for new implementations we should start using share_link_id'),
  "share_link_id": zod.string().nullish().describe('The ID of a Share Link to a message'),
  "stream_key": zod.string().nullish().describe('The stream key used to add audio to the message'),
  "socket_disconnects_while_streaming": zod.number().describe('The number of times the socket disconnected while the creator was sending audio'),
  "type": zod.enum(['channel', 'prerecorded', 'voicememo', 'stored', 'welcome']).nullable().describe('Message type'),
  "channel_sequence": zod.number().describe('The sequencial id of the message within the channel'),
  "last_heard_at": zod.string().datetime({}).describe('The last time anyone listened or cleared notified on this message'),
  "folder_id": zod.string().nullish().describe('Folder ID, only present when the message type is one of: voicememo,prerecorded')
})


/**
 * @summary Move a Folder into another Folder or into a Workspace
 */
export const moveFolderParams = zod.object({
  "id": zod.string()
})

export const moveFolderBody = zod.object({
  "workspace_id": zod.string().optional().describe('Workspace ID'),
  "folder_id": zod.string().optional().describe('Folder ID')
})

export const moveFolderResponseTotalNestedFoldersCountDefault = 0;export const moveFolderResponseTotalNestedMessagesCountDefault = 0;export const moveFolderResponseSubfoldersItemTotalNestedFoldersCountDefault = 0;export const moveFolderResponseSubfoldersItemTotalNestedMessagesCountDefault = 0;

export const moveFolderResponse = zod.object({
  "id": zod.string().describe('Unique Identifier'),
  "name": zod.string().describe('Name'),
  "creator_id": zod.string().describe('Creator'),
  "parent_folder_id": zod.string().optional().describe('Parent Folder ID'),
  "subfolder_ids": zod.array(zod.string()).optional().describe('List of Subfolder IDs'),
  "message_ids": zod.array(zod.string()).optional().describe('List of Message IDs'),
  "path": zod.array(zod.string()).optional().describe('Ordered List of all folders in the path from root to this folder'),
  "total_nested_folders_count": zod.number().describe('Total count for all Nested Folders'),
  "total_nested_messages_count": zod.number().describe('Total count for all Nested Messages'),
  "type": zod.enum(['voicememo', 'prerecorded']).describe('Folder type'),
  "workspace_id": zod.string().describe('Workspace ID where folder belongs to'),
  "created_at": zod.string().datetime({}),
  "last_updated_at": zod.string().datetime({}),
  "deleted_at": zod.string().datetime({}).optional(),
  "subfolders": zod.array(zod.object({
  "id": zod.string().describe('Unique Identifier'),
  "name": zod.string().describe('Name'),
  "creator_id": zod.string().describe('Creator'),
  "parent_folder_id": zod.string().optional().describe('Parent Folder ID'),
  "subfolder_ids": zod.array(zod.string()).optional().describe('List of Subfolder IDs'),
  "message_ids": zod.array(zod.string()).optional().describe('List of Message IDs'),
  "path": zod.array(zod.string()).optional().describe('Ordered List of all folders in the path from root to this folder'),
  "total_nested_folders_count": zod.number().describe('Total count for all Nested Folders'),
  "total_nested_messages_count": zod.number().describe('Total count for all Nested Messages'),
  "type": zod.enum(['voicememo', 'prerecorded']).describe('Folder type'),
  "workspace_id": zod.string().describe('Workspace ID where folder belongs to'),
  "created_at": zod.string().datetime({}),
  "last_updated_at": zod.string().datetime({}),
  "deleted_at": zod.string().datetime({}).optional()
})).optional().describe('Subfolders (only one deep level)')
})


